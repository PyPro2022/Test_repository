Пишем форму авторизации для Students.
 Написали ВФ get_students
 Написали прямой html прямо во вьюхе.
 Объяснение про форму <form> Что-то с action.
 Удалили action. ЧТо-то произошло.

 Чего-то там not found в консоли


пишем urls.py

path  []
добавляе create_student во ВФ

views.py:
    def create_student(reauest):
        pass

Добавляем модуль forms.py в папку проекта
    #ля форм сделаем отдельный класс
from gjango inmort forms
from .models import Student
class StudentCreateForms(forms.ModelForm):  #усть несколько классов форм. Мы будем использовать это
    class Meta:
        model = Student
        fields = [
         # '__all__' # все поля модели импортируются в форму
       'firs_name',
       'last_name',    # обычно выбирают какие поля отображать
        'age',  # эти поля из модели Ыегвутеы


        ]

возвращаемся во views.py

-> импорт csrf шняги
    "@csrf_exempt"
    def create_student(reauest):
        #метод запроса хранится в объекте request в атрибуте method
        if request.method == 'GET'
            method = 'GET'
        else:
            method = 'POST'
            #вкорячили форму
        return HttpResponce(method + 'CREATE') # в логе смотрим -Ю запрос методом GET. правка формы методом POST
 out: получили ошибку.
        Джанго хранить в себе защиту от перекрёстных запросов -Ю чтобы злой не смог подсунунть пользователю
        липовую форму. Джанго к форме прикорепляет CSRF токен к форме. При возврате сверяются токены. Если совпадают,
        то ОК. На нашей форме такого токена нет. Надо добавить: либо декоратор, либо шаблон.


-> импорт csrf шняги
    "@csrf_exempt"
    def create_student(reauest):
        if request.method == 'GET'
            html_form = """
                   код формы
                   """
            method = 'GET'
        else:
            method = 'POST'
            #вкорячили форму
        return HttpResponce(method + 'CREATE') # в логе смотрим -Ю запрос методом GET. правка формы методом POST


Смотрим html. Видим таблицу. 4 строки. Каждая = 1 поле нашей форме. Тег <input>и его атрибуты.
Имена полей = имена атрибутов в модели. Атрибут required = форма бязательна для заполнения.


Вкорячим html в заготовку.

    "@csrf_exempt"
    def create_student(reauest):
        #всё для гет запроса
        if request.method == 'GET'
            html_form = f""""
                   <form method='POST'>
                   <table>
                   {form.as_table()}  №#
                   </table>
                   """
            method = 'GET'
        else:
            method = 'POST'
            #вкорячили форму
        return HttpResponce(html_form+ 'CREATE') # в логе смотрим -Ю запрос методом GET. правка формы методом POST

Смотрим в браузере что получилось. Правим ошибки в html коде.

Всё получилось. Смотрим на старнице. ПОявилась форма. Можно заполнять.
В классе формы можно добавить как отображать данные????
forms
class Meta:
        model = Student
        fields = [
         # '__all__' # все поля модели импортируются в форму
       'firs_name',
       'last_name',    # обычно выбирают какие поля отображать
        'age',  # эти поля из модели Ыегвутеы
        ]

        widgets ={
            'birthday': ???   # прикрутили календарик на поле
        }

Показывают токен. Посмотрим в запросе.
Когда отправляем запрос
[Картинка]


    "@csrf_exempt"
    def create_student(reauest):
        #всё для гет запроса
        if request.method == 'GET'
            html_form = f""""
                   <form method='POST'>
                   <table>
                   {form.as_table()}  №#
                   </table>
                   """
            method = 'GET'
        #работаем с методом POST
        else:
            form = StudentCreateForm(request.POST) #обработали запрос
            if form.is.valid():
                form.save()
# теперь надо едирект на succes URL
        #Данные в объекте POST хранятся в виде словаря.
        return HttpResponceRedirect('/students/')

        return HttpResponce(html_form+ 'CREATE') # в логе смотрим -Ю запрос методом GET. правка формы методом POST

 [картинка srf токен]

 Смотрим в базе как добавились данные

 ------------Валидация
    Способы валидации.

models.py:
```    ....
    validators = [MinLenghtValidator(2)] # встроенный валидатор. надо импортировать

```
смотрим в браузере. Валидация не прошла + спец сообщения. Меняем. Проходим
По хорошему надо хранить birthday, а не age. На него и сделаем валидацию

Создаём -----------модуль validators.py:
    import datetime

    from django.core.exceptions import ValidationError

    ADULT_AGE_LIMIT = 18
    def adult_validator(birthday):
        #нужно вычислить возраст. проверить на соотв требованиям. если не соотв, то возбудить ValidationError

        age = datetime.date.today().year - birthday.year
        if age < ADULT_AGE_LIMIT:
            raise ValidationError ('Age shoukd be greater than 18 y.o.')


Чего-то добавили  в модель.
ПРоверяем в браузере. Всё ок.

   -----Модификация и валидация данных непосредственно в форме---

Для каждого поля джпнго создаёт спецметоды типа _clean_<имя поля>
Будем работать с полями first_name и last_name. ПРоверять чтобы не вводили абракадабру.
Нужно обработать строку -> capitalize

forms.py:
    ....
    def clean_first_name(self):
        fn = self.cleaned_data('first_name')
        return fn.title()


    def clean_last_name(self):
        ln = self.cleaned_data('first_name')
        return ln.title()

методы вызываются автоматически

Проверяем в формах. Всё работает.

-----Поле age
    Либо уьрать, либо ридонли.
    Это надо делать (расчёт возраста)в модели, в момент сохранения в БД

    Для этого переопределяем сандартный метод модели

   # def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        def save(self, *args, **kwargs):

        self.age = relativedelta(datetime.data.today(), self.birthday).years
         super().save(*args, **kwargs) #вызываем стандартный метод save

 Проверяем работает
 Хранить возраст в базе - плохая идея. Вариант: использовать метод. Но значения не будут пересчитываться.


